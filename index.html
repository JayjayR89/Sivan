<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puter Camera AI</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://js.puter.com/v2/"></script>
    <style>
        body {
            padding: 10px;
            background-color: #f8f9fa;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            font-size: 0.95rem;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }

        .app-header h5 {
            margin-bottom: 0;
            flex-grow: 1;
            text-align: center;
        }

        .app-header .status-indicator {
            font-size: 0.85em;
            color: #6c757d;
            margin: 0 10px;
            flex-shrink: 0;
        }

        video {
            width: 100%;
            height: auto;
            max-height: 360px;
            border-radius: 5px;
            background-color: #000;
            display: none;
            margin-bottom: 10px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #007bff;
            animation: spin 1s ease infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #statusMessage {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
            text-align: center;
        }

        #aiResponse {
            margin-top: 10px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            display: none;
            font-size: 0.875rem;
        }

        .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #6c757d;
            text-align: center;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        .btn-group-responsive {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn-group-responsive .btn {
            width: 100%;
        }

        @media (min-width: 576px) {
            .btn-group-responsive {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .btn-group-responsive .btn {
                flex: 1 1 auto;
                max-width: fit-content;
                min-width: 120px;
            }
        }

        /* Accessibility improvements */
        .btn:focus {
            outline: 2px solid #007bff;
            outline-offset: 2px;
        }

        /* Loading state styles */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .error-message {
            color: #dc3545;
            font-weight: 500;
        }

        .success-message {
            color: #28a745;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="app-header">
            <button id="loginLogoutButton" class="btn btn-sm btn-outline-primary" aria-label="Login or logout">
                Login
            </button>
            <span id="loginStatus" class="status-indicator" role="status" aria-live="polite">Not logged in.</span>
            <button id="settingsButton" class="btn btn-sm btn-outline-secondary" aria-label="Open settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>

        <div id="appContent" style="display: none;">
            <div class="camera-preview-box text-center">
                <video id="camera" autoplay playsinline aria-label="Camera preview"></video>
                <canvas id="canvas" style="display: none;" aria-hidden="true"></canvas>
                <button id="changeCameraButton" class="btn btn-secondary btn-sm mt-2" style="display: none;" aria-label="Switch to different camera">
                    <i class="fas fa-sync-alt"></i> Change Camera
                </button>
            </div>

            <div class="btn-group-responsive control-buttons">
                <button id="startButton" class="btn btn-info" aria-label="Start webcam">
                    Start Webcam
                </button>
                <button id="stopButton" class="btn btn-warning" disabled aria-label="Stop webcam">
                    Stop Webcam
                </button>
                <button id="captureButton" class="btn btn-success" disabled aria-label="Capture photo">
                    Capture Photo
                </button>
                <button id="describeButton" class="btn btn-primary" disabled aria-label="Describe photo with AI">
                    Describe Photo
                </button>
            </div>
            
            <p id="statusMessage" class="text-muted" role="status" aria-live="polite"></p>
            <div id="aiResponse" class="text-left" role="region" aria-label="AI response"></div>
        </div>

        <div class="footer">
            <a href="https://developer.puter.com" target="_blank">Powered by Puter</a>
        </div>
    </div>

    <script>
        // ===== CONSTANTS AND CONFIGURATION =====
        const DEBUG_MODE = false;
        const CACHE_DURATION = 30000; // 30 seconds
        const MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB
        const PERFORMANCE_THRESHOLD = 5000; // 5 seconds

        const LoadingStates = {
            IDLE: 'idle',
            STARTING_CAMERA: 'starting_camera',
            CAPTURING: 'capturing',
            PROCESSING_AI: 'processing_ai'
        };

        // ===== UTILITY FUNCTIONS =====
        function debugLog(message, data = null) {
            if (DEBUG_MODE) {
                console.log(`[DEBUG] ${message}`, data);
            }
        }

        function validateImageBlob(blob) {
            if (!blob || blob.size === 0) {
                throw new Error('Invalid image data');
            }
            
            if (blob.size > MAX_IMAGE_SIZE) {
                throw new Error('Image file too large (max 10MB)');
            }
            
            return true;
        }

        function getErrorMessage(error) {
            if (error.name === 'NotAllowedError') {
                return 'Camera access denied. Please allow camera permissions.';
            } else if (error.name === 'NotFoundError') {
                return 'No camera found. Please check your device.';
            } else if (error.name === 'NetworkError') {
                return 'Network error. Please check your connection.';
            } else if (error.name === 'NotSupportedError') {
                return 'Camera not supported on this device.';
            } else if (error.name === 'AbortError') {
                return 'Operation was cancelled.';
            }
            return `Error: ${error.message}`;
        }

        // ===== PERFORMANCE MONITORING =====
        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    captureTime: [],
                    aiResponseTime: [],
                    memoryUsage: []
                };
            }
            
            startTimer(operation) {
                return performance.now();
            }
            
            endTimer(startTime, operation) {
                const duration = performance.now() - startTime;
                this.metrics[operation].push(duration);
                
                if (duration > PERFORMANCE_THRESHOLD) {
                    console.warn(`Slow ${operation}: ${duration}ms`);
                }
                
                debugLog(`${operation} completed in ${duration}ms`);
                return duration;
            }
            
            getAverageTime(operation) {
                const times = this.metrics[operation];
                if (times.length === 0) return 0;
                return times.reduce((a, b) => a + b, 0) / times.length;
            }
        }

        const performanceMonitor = new PerformanceMonitor();

        // ===== FILE MANAGEMENT =====
        class FileManager {
            constructor() {
                this.temporaryFiles = new Set();
            }
            
            async saveTemporaryFile(blob, filename) {
                try {
                    validateImageBlob(blob);
                    const puterFile = await puter.fs.write(filename, blob);
                    this.temporaryFiles.add(puterFile.path);
                    debugLog('Temporary file saved', { path: puterFile.path, size: blob.size });
                    return puterFile;
                } catch (error) {
                    throw new Error(`Failed to save file: ${error.message}`);
                }
            }
            
            async cleanupTemporaryFiles() {
                const cleanupPromises = Array.from(this.temporaryFiles).map(async (path) => {
                    try {
                        await puter.fs.delete(path);
                        this.temporaryFiles.delete(path);
                        debugLog('Temporary file deleted', { path });
                    } catch (error) {
                        console.error(`Failed to delete temporary file ${path}:`, error);
                    }
                });
                
                await Promise.allSettled(cleanupPromises);
            }
            
            async cleanupSpecificFile(path) {
                if (this.temporaryFiles.has(path)) {
                    try {
                        await puter.fs.delete(path);
                        this.temporaryFiles.delete(path);
                        debugLog('Specific temporary file deleted', { path });
                    } catch (error) {
                        console.error(`Failed to delete file ${path}:`, error);
                    }
                }
            }
        }

        const fileManager = new FileManager();

        // ===== CAMERA MANAGEMENT =====
        class CameraManager {
            constructor() {
                this.currentStream = null;
                this.videoDevices = [];
                this.currentDeviceIndex = 0;
                this.deviceCache = null;
                this.deviceCacheExpiry = 0;
            }
            
            isValidStream(stream) {
                return stream && stream.active && stream.getTracks().length > 0;
            }
            
            async getAvailableVideoDevices() {
                const now = Date.now();
                
                if (this.deviceCache && now < this.deviceCacheExpiry) {
                    return this.deviceCache;
                }
                
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.videoDevices = devices.filter(device => device.kind === 'videoinput');
                    this.deviceCache = this.videoDevices;
                    this.deviceCacheExpiry = now + CACHE_DURATION;
                    debugLog('Video devices enumerated', { count: this.videoDevices.length });
                    return this.videoDevices;
                } catch (error) {
                    handleError(error, 'device_enumeration');
                    return [];
                }
            }
            
            async startWebcam() {
                if (this.isValidStream(this.currentStream)) {
                    this.stopWebcam();
                }

                const startTime = performanceMonitor.startTimer('webcam_start');
                statusMessage.textContent = 'Requesting webcam access...';
                
                try {
                    await this.getAvailableVideoDevices();

                    if (this.videoDevices.length === 0) {
                        throw new Error('No camera devices found.');
                    }

                    const constraints = {
                        video: {
                            deviceId: this.videoDevices[this.currentDeviceIndex] ? 
                                { exact: this.videoDevices[this.currentDeviceIndex].deviceId } : 
                                undefined
                        },
                        audio: false
                    };

                    this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = this.currentStream;
                    video.style.display = 'block';
                    
                    uiManager.updateButtonStates(LoadingStates.IDLE);
                    statusMessage.textContent = `Webcam active (Device: ${this.videoDevices[this.currentDeviceIndex]?.label || 'Default'}). Ready to capture.`;
                    uiManager.hideSpinner();
                    aiResponseDiv.textContent = '';
                    lastCapturedFilePuterPath = null;
                    
                    performanceMonitor.endTimer(startTime, 'webcam_start');
                    debugLog('Webcam started successfully', { deviceIndex: this.currentDeviceIndex });

                } catch (err) {
                    performanceMonitor.endTimer(startTime, 'webcam_start');
                    handleError(err, 'webcam');
                }
            }
            
            stopWebcam() {
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                    video.style.display = 'none';
                    this.currentStream = null;
                    statusMessage.textContent = 'Webcam stopped.';
                    debugLog('Webcam stopped');
                }
                uiManager.resetUIState();
                lastCapturedFilePuterPath = null;
                uiManager.hideSpinner();
                aiResponseDiv.textContent = '';
            }
            
            async changeCamera() {
                this.currentDeviceIndex = (this.currentDeviceIndex + 1) % this.videoDevices.length;
                await this.startWebcam();
            }
            
            cleanup() {
                this.stopWebcam();
                fileManager.cleanupTemporaryFiles();
            }
        }

        // ===== UI MANAGEMENT =====
        class UIManager {
            constructor() {
                this.currentLoadingState = LoadingStates.IDLE;
            }
            
            setLoadingState(state) {
                this.currentLoadingState = state;
                this.updateUIForLoadingState();
            }
            
            updateUIForLoadingState() {
                const buttons = [startButton, stopButton, captureButton, describeButton, changeCameraButton];
                
                buttons.forEach(button => {
                    button.disabled = this.currentLoadingState !== LoadingStates.IDLE;
                });
                
                const statusMessages = {
                    [LoadingStates.STARTING_CAMERA]: 'Starting camera...',
                    [LoadingStates.CAPTURING]: 'Capturing photo...',
                    [LoadingStates.PROCESSING_AI]: 'AI is analyzing image...'
                };
                
                statusMessage.textContent = statusMessages[this.currentLoadingState] || '';
            }
            
            updateButtonStates(state) {
                switch (state) {
                    case LoadingStates.IDLE:
                        startButton.disabled = false;
                        stopButton.disabled = true;
                        captureButton.disabled = true;
                        describeButton.disabled = true;
                        changeCameraButton.disabled = false;
                        break;
                    case LoadingStates.STARTING_CAMERA:
                        startButton.disabled = true;
                        stopButton.disabled = true;
                        captureButton.disabled = true;
                        describeButton.disabled = true;
                        changeCameraButton.disabled = true;
                        break;
                    case 'camera_active':
                        startButton.disabled = true;
                        stopButton.disabled = false;
                        captureButton.disabled = false;
                        describeButton.disabled = true;
                        changeCameraButton.disabled = false;
                        break;
                    case 'photo_captured':
                        startButton.disabled = true;
                        stopButton.disabled = false;
                        captureButton.disabled = false;
                        describeButton.disabled = false;
                        changeCameraButton.disabled = false;
                        break;
                }
            }
            
            resetUIState() {
                this.updateButtonStates(LoadingStates.IDLE);
            }
            
            showSpinner(message = 'Processing...') {
                aiResponseDiv.style.display = 'block';
                aiResponseDiv.innerHTML = `<div class="spinner"></div><p class="text-center mt-3">${message}</p>`;
            }
            
            hideSpinner() {
                aiResponseDiv.innerHTML = '';
                aiResponseDiv.style.display = 'none';
            }
            
            showError(message) {
                statusMessage.textContent = message;
                statusMessage.className = 'text-muted error-message';
            }
            
            showSuccess(message) {
                statusMessage.textContent = message;
                statusMessage.className = 'text-muted success-message';
            }
            
            clearStatus() {
                statusMessage.className = 'text-muted';
            }
        }

        // ===== AI SERVICE =====
        class AIService {
            async describeImage(imagePath) {
                const startTime = performanceMonitor.startTimer('ai_response');
                
                try {
                    const prompt = 'Please describe this image in detail, providing key objects, actions, and overall context.';
                    const aiResponse = await puter.ai.chat(
                        prompt, 
                        imagePath,
                        { stream: true }
                    );

                    aiResponseDiv.textContent = '';
                    for await (const part of aiResponse) {
                        if (part?.text) {
                            aiResponseDiv.textContent += part.text;
                            aiResponseDiv.scrollTop = aiResponseDiv.scrollHeight;
                        }
                    }
                    
                    performanceMonitor.endTimer(startTime, 'ai_response');
                    return true;
                } catch (error) {
                    performanceMonitor.endTimer(startTime, 'ai_response');
                    throw error;
                }
            }
        }

        // ===== ERROR HANDLING =====
        function handleError(error, context) {
            console.error(`Error in ${context}:`, error);
            const userMessage = getErrorMessage(error);
            uiManager.showError(userMessage);
            
            if (context === 'webcam' || context === 'ai') {
                uiManager.resetUIState();
            }
        }

        // ===== DOM ELEMENTS =====
        const loginLogoutButton = document.getElementById('loginLogoutButton');
        const loginStatusSpan = document.getElementById('loginStatus');
        const settingsButton = document.getElementById('settingsButton');
        const appContent = document.getElementById('appContent');
        const video = document.getElementById('camera');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const captureButton = document.getElementById('captureButton');
        const describeButton = document.getElementById('describeButton');
        const changeCameraButton = document.getElementById('changeCameraButton');
        const statusMessage = document.getElementById('statusMessage');
        const aiResponseDiv = document.getElementById('aiResponse');

        // ===== STATE VARIABLES =====
        let lastCapturedFilePuterPath = null;

        // ===== INSTANCES =====
        const cameraManager = new CameraManager();
        const uiManager = new UIManager();
        const aiService = new AIService();

        // ===== CANVAS UTILITIES =====
        function cleanupCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

        // ===== AUTHENTICATION LOGIC =====
        async function updateLoginUI() {
            const isSignedIn = await puter.auth.isSignedIn();
            if (isSignedIn) {
                const user = await puter.auth.getUser();
                loginStatusSpan.textContent = `Logged in as ${user.username}.`;
                loginLogoutButton.textContent = 'Logout';
                loginLogoutButton.classList.remove('btn-outline-primary');
                loginLogoutButton.classList.add('btn-danger');
                appContent.style.display = 'flex';
                statusMessage.textContent = 'Welcome! Start webcam to begin.';
                debugLog('User logged in', { username: user.username });
            } else {
                loginStatusSpan.textContent = 'Not logged in.';
                loginLogoutButton.textContent = 'Login';
                loginLogoutButton.classList.remove('btn-danger');
                loginLogoutButton.classList.add('btn-outline-primary');
                appContent.style.display = 'none';
                statusMessage.textContent = 'Please log in to use the app features.';
                cameraManager.stopWebcam();
                debugLog('User logged out');
            }
        }

        async function handleLoginLogout() {
            if (await puter.auth.isSignedIn()) {
                statusMessage.textContent = 'Logging out...';
                await puter.auth.signOut();
                statusMessage.textContent = 'Logged out.';
            } else {
                statusMessage.textContent = 'Opening login dialog...';
                await puter.auth.signIn();
            }
            await updateLoginUI();
        }

        // ===== SETTINGS POPUP =====
        async function showSettings() {
            await puter.ui.createWindow({
                title: 'App Settings',
                content: `<div style="padding: 20px; text-align: center;">
                            <p>Settings coming soon!</p>
                            <p>This is a placeholder for future configurations like AI model selection, etc.</p>
                          </div>`,
                width: 400,
                height: 250,
                is_resizable: false,
                has_head: true,
                center: true,
                show_in_taskbar: false,
                disable_parent_window: true
            });
        }

        // ===== CAPTURE AND AI LOGIC =====
        async function capturePhoto() {
            if (!cameraManager.isValidStream(cameraManager.currentStream)) {
                uiManager.showError('Webcam not started. Please start webcam first.');
                return;
            }

            uiManager.setLoadingState(LoadingStates.CAPTURING);
            uiManager.hideSpinner();
            aiResponseDiv.textContent = '';
            lastCapturedFilePuterPath = null;

            const startTime = performanceMonitor.startTimer('capture');

            try {
                if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }

                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(async (blob) => {
                    try {
                        validateImageBlob(blob);
                        const filename = `webcam_snapshot_${Date.now()}.png`;
                        const puterFile = await fileManager.saveTemporaryFile(blob, filename);
                        lastCapturedFilePuterPath = puterFile.path;
                        
                        uiManager.showSuccess(`✅ Photo captured and saved. Ready for description.`);
                        uiManager.updateButtonStates('photo_captured');
                        performanceMonitor.endTimer(startTime, 'capture');
                        
                    } catch (error) {
                        handleError(error, 'capture');
                        performanceMonitor.endTimer(startTime, 'capture');
                    } finally {
                        cleanupCanvas();
                        uiManager.setLoadingState(LoadingStates.IDLE);
                    }
                }, 'image/png');

            } catch (error) {
                handleError(error, 'capture');
                performanceMonitor.endTimer(startTime, 'capture');
                uiManager.setLoadingState(LoadingStates.IDLE);
            }
        }

        async function describePhotoWithAI() {
            if (!lastCapturedFilePuterPath) {
                uiManager.showError('No photo has been captured yet to describe.');
                return;
            }

            uiManager.setLoadingState(LoadingStates.PROCESSING_AI);
            uiManager.showSpinner('AI is analyzing the image...');

            try {
                await aiService.describeImage(lastCapturedFilePuterPath);
                uiManager.showSuccess('AI description complete.');

                // Clean up the temporary file after AI description
                await fileManager.cleanupSpecificFile(lastCapturedFilePuterPath);
                lastCapturedFilePuterPath = null;

            } catch (error) {
                handleError(error, 'ai');
                aiResponseDiv.textContent = 'Error getting AI description: ' + error.message;
            } finally {
                uiManager.hideSpinner();
                uiManager.setLoadingState(LoadingStates.IDLE);
            }
        }

        // ===== EVENT HANDLERS =====
        async function handleStartWebcam() {
            uiManager.setLoadingState(LoadingStates.STARTING_CAMERA);
            await cameraManager.startWebcam();
        }

        function handleStopWebcam() {
            cameraManager.stopWebcam();
        }

        async function handleChangeCamera() {
            uiManager.setLoadingState(LoadingStates.STARTING_CAMERA);
            await cameraManager.changeCamera();
        }

        // ===== KEYBOARD NAVIGATION =====
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && document.activeElement === captureButton) {
                capturePhoto();
            } else if (event.key === 'Escape' && cameraManager.isValidStream(cameraManager.currentStream)) {
                handleStopWebcam();
            }
        });

        // ===== INITIALIZATION =====
        updateLoginUI();

        // ===== EVENT LISTENERS =====
        loginLogoutButton.addEventListener('click', handleLoginLogout);
        settingsButton.addEventListener('click', showSettings);
        startButton.addEventListener('click', handleStartWebcam);
        stopButton.addEventListener('click', handleStopWebcam);
        captureButton.addEventListener('click', capturePhoto);
        describeButton.addEventListener('click', describePhotoWithAI);
        changeCameraButton.addEventListener('click', handleChangeCamera);

        // ===== CLEANUP ON WINDOW CLOSE =====
        puter.ui.onWindowClose(function() {
            cameraManager.cleanup();
            debugLog('App cleanup completed on window close');
        });

        // ===== PERFORMANCE MONITORING LOGGING =====
        if (DEBUG_MODE) {
            setInterval(() => {
                const avgCaptureTime = performanceMonitor.getAverageTime('captureTime');
                const avgAiTime = performanceMonitor.getAverageTime('aiResponseTime');
                debugLog('Performance metrics', { avgCaptureTime, avgAiTime });
            }, 30000); // Log every 30 seconds in debug mode
        }
    </script>
</body>

</html>
